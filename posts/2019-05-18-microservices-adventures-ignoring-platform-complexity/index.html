<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Blog  | Microservices adventures: Ignoring platform complexity</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.37.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/blog/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Microservices adventures: Ignoring platform complexity" />
<meta property="og:description" content="Microservices adventures: Ignoring platform complexity [Published codurance.com Medium]
  Figure 1. The three wise monkeys — Photo by Joao Tzanno on Unsplash  I think there is a common misconception about microservices out there.
 The popular opinion is that microservices supposed to be the cure for all of our problems. However, I say that by themselves, they can only cure half of them. To cure the other half, you are supposed to combine microservices with the latest DevBizSecDbaQaOps practices and transform your company into the ultimate buzzword producing killing machine and achieve Continuous Deployment nirvana." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hoto.github.io/blog/posts/2019-05-18-microservices-adventures-ignoring-platform-complexity/" />



<meta property="article:published_time" content="2019-05-18T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2019-05-18T00:00:00&#43;00:00"/>











<meta itemprop="name" content="Microservices adventures: Ignoring platform complexity">
<meta itemprop="description" content="Microservices adventures: Ignoring platform complexity [Published codurance.com Medium]
  Figure 1. The three wise monkeys — Photo by Joao Tzanno on Unsplash  I think there is a common misconception about microservices out there.
 The popular opinion is that microservices supposed to be the cure for all of our problems. However, I say that by themselves, they can only cure half of them. To cure the other half, you are supposed to combine microservices with the latest DevBizSecDbaQaOps practices and transform your company into the ultimate buzzword producing killing machine and achieve Continuous Deployment nirvana.">


<meta itemprop="datePublished" content="2019-05-18T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-05-18T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2357">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Microservices adventures: Ignoring platform complexity"/>
<meta name="twitter:description" content="Microservices adventures: Ignoring platform complexity [Published codurance.com Medium]
  Figure 1. The three wise monkeys — Photo by Joao Tzanno on Unsplash  I think there is a common misconception about microservices out there.
 The popular opinion is that microservices supposed to be the cure for all of our problems. However, I say that by themselves, they can only cure half of them. To cure the other half, you are supposed to combine microservices with the latest DevBizSecDbaQaOps practices and transform your company into the ultimate buzzword producing killing machine and achieve Continuous Deployment nirvana."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://hoto.github.io/blog/" class="f3 fw2 hover-white no-underline white-90 dib">
      Blog
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Microservices adventures: Ignoring platform complexity</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2019-05-18T00:00:00Z">May 18, 2019</time>      
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><div class="sect1">
<h2 id="_microservices_adventures_ignoring_platform_complexity">Microservices adventures: Ignoring platform complexity</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>[Published <a href="https://codurance.com/2019/05/18/microservices-adventures/">codurance.com</a> <a href="https://medium.com/@AndrzejRehmann/microservices-adventures-ignoring-platform-complexity-b1820d8fb53d">Medium</a>]</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/images/2019-05-18-microservices-adventures/three-monkeys.jpg" alt="three monkeys">
</div>
<div class="title">Figure 1. The three wise monkeys — Photo by <a href="https://unsplash.com/photos/1NacmxqfPZA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joao Tzanno</a> on Unsplash</div>
</div>
<div class="paragraph">
<p>I think there is a common misconception about microservices out there.</p>
</div>
<div class="paragraph">
<p>The popular opinion is that microservices supposed to be the cure for all of our problems.
However, I say that by themselves, they can only cure half of them.
To cure the other half, you are supposed to combine microservices with the latest DevBizSecDbaQaOps practices and transform your company into the ultimate buzzword producing killing machine and achieve Continuous Deployment nirvana.</p>
</div>
<div class="paragraph">
<p>But seriously.</p>
</div>
<div class="paragraph">
<p>Microservices were supposed to enable companies to perform gazillion deployments per day, scale the system up to infinity, reduce the codebase complexity, and save money at the same time.</p>
</div>
<div class="paragraph">
<p>Few, however, ask what is the price for this?</p>
</div>
<div class="paragraph">
<p>In my opinion, the price is the increase in platform complexity.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Microservices shift the complexity from the services to the platform.
Ignoring this fact results in the suboptimal results.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_complexity">Complexity</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Complex - many parts with intricate arrangements, organized (easy) or disorganized (hard)</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Complicated - hard to understand regardless of the complexity</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Sometimes things may seem complicated at first but become complex with enough familiarity (think driving a car).</p>
</div>
<div class="paragraph">
<p>We can describe any software system on how complicated and complex it is.
The system can be made less complicated and complex by removing pieces of it.
When splitting a system into pieces, it may become less complicated, but the complexity usually increases.</p>
</div>
<div class="paragraph">
<p>Thankfully splitting can be done in such a way that we end up with an "organized" complexity, which is easy to understand.
However, that, in my opinion, is an art and requires not only expertise but a ton of experience.</p>
</div>
<div class="paragraph">
<p>When going from a monolith to microservices, we split services reducing their complexity, but the complexity does not disappear into thin air, it transfers onto the platform.</p>
</div>
<div class="paragraph">
<p>Because designing a platform for distributed systems on a large scale is not yet a mainstream concept, many companies don&#8217;t realize they have to change tactics and fall short when giving in the microservices hype.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_definition">Platform definition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The software which is not a shelfware eventually ends up running on a platform.
The platform is all the things which enable the software to run and perform its duty.
When the platform fails, your software fails.</p>
</div>
<div class="paragraph">
<p>My definition of a software platform includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Platform topology</strong> - existing infrastructure</p>
</li>
<li>
<p><strong>Services</strong> - executable units of software</p>
<div class="ulist">
<ul>
<li>
<p><strong>Core services</strong> - executables required to fulfill business needs</p>
</li>
<li>
<p><strong>Support services</strong> - executables monitoring core services and the platform itself</p>
</li>
<li>
<p><strong>Service Orchestration</strong> - executables assigning which service goes where also responsible for scaling and destroying services</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Service Configuration</strong> - configuration which changes depending on the environment</p>
</li>
<li>
<p><strong>Service Secrets</strong> - configuration which should not be source controlled</p>
</li>
<li>
<p><strong>Service Discovery</strong> - detection of services</p>
</li>
<li>
<p><strong>Service Mesh</strong> - delivery of requests through a topology</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, we have things which describe the platform setup and deployment procedures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Platform definition</strong> - procedures (hopefully in code) describing in details the infrastructure</p>
</li>
<li>
<p><strong>Deployment pipelines</strong> - procedures (hopefully in code) describing the deployment process</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every platform is alive, evolving, and has a lifecycle:</p>
</div>
<div class="paragraph">
<p><strong>Day 1</strong></p>
</div>
<div class="paragraph">
<p>There is nothing.
Infrastructure gets created, and software gets deployment for the first time.</p>
</div>
<div class="paragraph">
<p><strong>Day 2+</strong></p>
</div>
<div class="paragraph">
<p>Infrastructure gets removed, updated, or extended.
Configuration changes.
Software crashes.
Software gets redeployed.
Deployment fails and needs a rollback.</p>
</div>
<div class="paragraph">
<p>Challenging problems arise not on day 1, but on day 2 onwards.
If you don&#8217;t plan and think ahead on the first day, you may be in a need one day to scrap your whole platform and go back to the drawing board.</p>
</div>
<div class="paragraph">
<p>There are many things which can go wrong here.
What&#8217;s inside the boxes (services) is irrelevant, the thing which handles the boxes and connection between them should be the main focus of attention.
If the company thinks that the services are more crucial then the platform, then I would recommend staying with monoliths.</p>
</div>
<div class="paragraph">
<p>The platform is like a free puppy.
The upfront cost may be zero, but when the puppy grows and multiplies the maintenance costs grows exponentially.
Eventually, a badly designed and poorly maintained platform behaves in the most unexpected ways up to a point where instead of fixing the current one, it&#8217;s cheaper to create a new one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_as_an_afterthought">Platform as an afterthought</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two cases when starting with microservices architecture:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Starting fresh - what we call a greenfield project.</p>
</li>
<li>
<p>Migrating from a monolith by extracting bits from it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Unfortunately, both cases usually suffer from the same symptoms:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Platform design is often an afterthought.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The platform usually comes up in the conversations as the "supporting" role, rarely as the main actor.
Companies who change their viewpoint and reverse this situation shall be the one to reap the full benefits of microservice architecture.
Who knows, maybe even all of the devops catchphrases from the company "we are hiring" page will then come alive like in a fairy tale and mingle among the dancing developers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitoring_observability_and_debuggability">Monitoring, observability and debuggability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Monitoring is gathering and displaying data so it can be analyzed.
To monitor a system, it must be observable.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If you are observable I can understand you.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The tools and techniques needed to analyze a system composed of couple services vs. hundredths of services are vastly different.
Where one can manage to manually gather and sift through metrics for a few services, doing so for dozens is not sustainable.
Any large scale microservice system needs tools to automatically gather all the essential metrics and display them in a format consumable to humans.</p>
</div>
<div class="sect2">
<h3 id="_black_box">Black box</h3>
<div class="paragraph">
<p>The opposite of an observable system is a "black box," where the only things we can measure are the inputs and outputs (or a lack thereof).
In this hugely entertaining <a href="https://www.youtube.com/watch?v=30jNsCVLpAE">talk</a> Bryan Cantrill talks about the art of debuggability:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The art of debugging isn&#8217;t to guess the answer - it is to be able to ask the right questions to know how to answer them.
Answered questions are facts, not a hypothesis.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Making platform observable is hard and under-appreciated work.
When a deployment is a non-event, nobody congratulates the people behind it.</p>
</div>
<div class="paragraph">
<p>In my opinion, successfully pulling out microservices architecture requires putting more effort into the platform itself than on the services running on it.
Companies need to realize they are creating a platform first, and the services running on it are the afterthought.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_engineers">Platform engineers</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Systems are as good as the people who designed it.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Systems fail, and that is something to be expected and embraced.
However, they should also self recover.
How, you ask?
Preferably without the input of humans.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>With any advanced automation, the weakest link is always the human.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>A self-healing system requires self-monitoring capabilities.
To monitor anything, you need observability.
Observability and monitoring should then be a priority, not an afterthought.
To design, setup, and maintain platform monitoring, we need platform engineers.</p>
</div>
<div class="paragraph">
<p>Humans should be in the loop only when the system cannot repair itself.
Our job should not only be fixing the problems but primarily making sure that those problems never occur again or gets fixed automatically next time.</p>
</div>
<div class="paragraph">
<p>When dealing with complex platforms, we need "platform engineers."
Those are either system administrators who can code or coders who know system administration.
They write code to make the platform more observable, stable, and developer friendly.</p>
</div>
<div class="paragraph">
<p>Best results are achieved when the platform engineers are not an isolated team but part of the development teams.
An ideal situation is when all your developers can be considered platform engineers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_common_oversights">Common oversights</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Some people change their ways when they see the light; others when they feel the heat."</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In my opinion, the most common oversights when dealing with microservices are:</p>
</div>
<div class="sect2">
<h3 id="_1_lack_of_monitoring">1. Lack of monitoring</h3>
<div class="quoteblock">
<blockquote>
<div class="literalblock">
<div class="content">
<pre>"It’s pretty incredible when we stop assuming we know what’s going on."</pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Observability needs to be built into the platform from the very beginning.
Don&#8217;t make a mistake of going into production and then worry about observability, at that time it may be too late.</p>
</div>
<div class="paragraph">
<p>SLIs, SLAs, and SLOs, which boils down to <a href="https://cloud.google.com/blog/products/gcp/sre-fundamentals-slis-slas-and-slos">availability</a>, should be agreed up front and be monitored.
To monitor those values, you need observability.</p>
</div>
<div class="paragraph">
<p>Often there is a question who should be looking at the monitoring, and my answer would be to ask this:</p>
</div>
<div class="paragraph">
<p>Who cares about not breaking the SLA and what happens when it&#8217;s broken?</p>
</div>
<div class="paragraph">
<p>If the answer is "nobody" and "nothing," then you don&#8217;t need monitoring in the first place because nobody cares if the system is working or not.
However, if there is a penalty for breaking the SLA, then the answer clarifies itself.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"People are not afraid of failure, they are afraid of blame."</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_2_wrong_tools_for_alerts_or_no_alerting">2. Wrong tools for alerts (or no alerting)</h3>
<div class="paragraph">
<p>Getting spammed by dozens of occurrences of the same alert makes the receivers desensitized.
Same types of alerts should automatically get grouped.
Receiving a notification for the same alert multiple times is much different than getting spammed with copies of it.</p>
</div>
<div class="paragraph">
<p>Every alert needs to have an assignee and a status.
You don&#8217;t want people working on the same issue in parallel without knowing the problem was fixed yesterday by someone else.</p>
</div>
<div class="paragraph">
<p>Every alert needs at least the source of origin and the action to follow.
Humans fix problems quickly if there is a clear procedure for how to deal with them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_not_following_the_a_href_https_12factor_net_twelve_factors_a_rules">3. Not following the <a href="https://12factor.net/">twelve factors</a> rules</h3>
<div class="paragraph">
<p>It makes me sad when I see an application in 2019 which instead of logging to stdout logs to a file.
Twelve factors rules are the basics and the lowest hanging fruits to pick.</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_making_artifacts_mutable">4. Making artifacts mutable</h3>
<div class="paragraph">
<p>It is unacceptable to have to rebuild the artifact to change its runtime configuration.
Artifacts should be built once and be deployable to any environment.
You can pass or select the config with environment variables or read an external config file.</p>
</div>
<div class="paragraph">
<p>Immutable artifacts are useful because every build is slightly different.
The same artifact built twice may behave differently in the same conditions.
We want to avoid that.</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_not_having_a_common_logging_strategy">5. Not having a common logging strategy</h3>
<div class="paragraph">
<p>Nobody looks at logs for fun.
We use them when debugging or when creating a baseline for the system pulse (think heart rate monitor but for software).
Analyzing logs from services using different logging schemes is just too complicated.
Just come up with a logging strategy which everybody agrees on and make a logging library for everybody to use.</p>
</div>
<div class="paragraph">
<p>If you cannot enforce a common strategy, then automatically normalize the log streams before they end up presented to a human.</p>
</div>
<div class="paragraph">
<p>Standardized logging scheme is also crucial for making useful dashboards.</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_not_a_href_https_zipkin_apache_org_tracing_a_network_calls">6. Not <a href="https://zipkin.apache.org/">tracing</a> network calls</h3>
<div class="paragraph">
<p>When a function call crash we get a stack trace with all the calls from start to finish.
In microservices, calls can jump from service to service, and when one fails, it&#8217;s crucial to see the whole flow.</p>
</div>
<div class="paragraph">
<p>It is incredibly useful and insightful to be able to trace a single call throughout the system.</p>
</div>
<div class="paragraph">
<p>Tracking individual calls may seem daunting at first, but implementation is straightforward.
Usually, it&#8217;s a middle man which marks the network calls and logs the event.
Logs are then used to produce visualizations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_designing_pipelines_without_automated_rollbacks">7. Designing pipelines without automated rollbacks</h3>
<div class="paragraph">
<p>To have an automated rollback, you need auto detection when something goes wrong.
How the system detects and decides if something went wrong separates Continuous Deployment wannabes from the pros.</p>
</div>
</div>
<div class="sect2">
<h3 id="_8_not_requiring_health_checks">8. Not requiring health checks</h3>
<div class="paragraph">
<p>Every service needs to answer one fundamental question: is it healthy or not.
Of course, health check status from the application should be just one of many metrics collected by the orchestrator to decide if a service is healthy.
There may be many issues that the service is not aware of.</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_not_using_a_service_mesh">9. Not using a Service Mesh</h3>
<div class="paragraph">
<p>When replacing function calls (monolith) for network calls (microservices), we need to accommodate for latency, network errors, and packet drops.
Doing retries directly from the service may seem harmless, but it may cause system-wide cascading failures and put unnecessary strain on the network.</p>
</div>
<div class="paragraph">
<p>Instead of forcing each service to deal with network failures, we can use a middle man called Service Mesh, which is designed to handle those cases.
It is true that we are still making a network call to a service mesh, but it is safer because the call is not leaving the host.</p>
</div>
<div class="paragraph">
<p>Service mesh also gives us essential features like retries policies, call timeouts, deadlines and <a href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breaking</a>.
It also makes it easier to have a system-wide call tracing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_10_not_adapting_the_tools_with_scale">10. Not adapting the tools with scale</h3>
<div class="paragraph">
<p>Many years ago, I joined a project where, at the very beginning, the platform was running just a handful of services.
The tool for orchestrating services was very primitive.
The biggest flaw of that orchestrator was that it didn&#8217;t respect the capacity of the hosts.
Service assignment to a host was manual.
The manual assignment works just fine with a tiny platform, but it just did not scale.
We had to estimate how much memory and CPU each service needs and assign them accordingly.
Sometimes the estimates were wrong, and one service would crash or starve other services.</p>
</div>
<div class="paragraph">
<p>When we scaled from a couple of services to dozens, we should have changed the tool, but we didn&#8217;t.
At that time, I didn&#8217;t even understand the problem as I was new to the subject, so did the vast majority of the people on the project.
Those who knew what was wrong didn&#8217;t care or were too afraid to escalate the problem to the decision makers.
The platform became incredibly unstable and required daily manual restarts, and soon it was late to replace the orchestrator, it got too deeply embedded into the platform.
It took more than a year to acknowledge the problem and design a new platform from scratch.</p>
</div>
<div class="paragraph">
<p>Conclusion: the platform needs to be checked periodically to asses if it still suits the needs of a system.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ending_words">Ending words</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Its been about 10 years since the microservices became mainstream.
The industry is still coming up with new tools, solutions, and patterns to make our life easier.
Keeping up with "devops" technology can be fatiguing and overwhelming, so instead, I think it is better to learn the underlying concepts which are universal and evolve slowly.</p>
</div>
</div>
</div>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://hoto.github.io/blog/" >
    &copy; 2019 Blog
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/blog/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
